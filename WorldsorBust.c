#pragma config(I2C_Usage, I2C1, i2cSensors)
#pragma config(Sensor, I2C_1,  ,               sensorQuadEncoderOnI2CPort,    , AutoAssign )
#pragma config(Sensor, I2C_2,  ,               sensorQuadEncoderOnI2CPort,    , AutoAssign )
#pragma config(Motor,  port1,           IW1,           tmotorVex393HighSpeed_HBridge, openLoop)
#pragma config(Motor,  port2,           DW1,           tmotorVex393HighSpeed_MC29, openLoop)
#pragma config(Motor,  port3,           DW2,           tmotorVex393HighSpeed_MC29, openLoop)
#pragma config(Motor,  port4,           DW3,           tmotorVex393HighSpeed_MC29, openLoop)
#pragma config(Motor,  port5,           DW4,           tmotorVex393HighSpeed_MC29, openLoop)
#pragma config(Motor,  port6,           flyWheelL1,    tmotorVex393_MC29, openLoop, encoderPort, I2C_1)
#pragma config(Motor,  port7,           flyWheelL2,    tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port8,           flyWheelR1,    tmotorVex393_MC29, openLoop, encoderPort, I2C_2)
#pragma config(Motor,  port9,           flyWheelR2,    tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port10,          IW2,           tmotorVex393HighSpeed_HBridge, openLoop)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

float power;
float velocity;
float error;
task shooterControl; //defines shooterControl don't touch this
task getVelocity;

task main()
{
	while(1 == 1)
{
//	int flywheel_on;
	//flywheel_on = -1;
//dummy text for flywheel
if(vexRT[BtnXX] == 1 ){
	power = 65;
	startTask (shooterControl);
}


 //Intake

  if(vexRT[Btn7L] == 1)
  {
	motor[IW1] = 127;
	motor[IW2] = 127;
	}
	else
	{
		if(vexRT[Btn7D] == 1)
		{
				motor[IW1] = -127;
				motor[IW2] = -127;
	}
		else
		{
	motor[IW1] = 0;
	motor[IW2] = 0;
		}
	}

	//drive control

  if(vexRT[Btn6U] == 1 )
  {
  	motor[DW1] = -75;
  	motor[DW2] = -75;
  	motor[DW3] = -75;
  	motor[DW4] = -75;
  }
  else if(vexRT[Btn5U] == 1)
	  {
	  motor[DW1] = 75;
  	motor[DW2] = 75;
  	motor[DW3] = 75;
  	motor[DW4] = 75;
		}
	else if(vexRT[Ch2] > 15) {
				motor[DW1] = -100;
				motor[DW2] = 100;
				motor[DW3] = 100;
				motor[DW4] = -100;
			}
	else if(vexRT[Ch2] < -15)
					{
								motor[DW1] = 100;
								motor[DW2] = -100;
								motor[DW3] = -100;
								motor[DW4] = 100;
					}
		else
			{
				motor[DW1] = 0;
				motor[DW2] = 0;
				motor[DW3] = 0;
				motor[DW4] = 0;
			}


}
}

task shooterControl()
{
float kp = 0.01; //proportional constant
float ki = 0.000000; //integral constant
float kd =0.00; //derivative constant

float current = 0; //starts with no power

float integralActiveZone = 2; //integral error accumulates

float errorT; //total error
float lastError; //last error recored
float proportion; //proportion term
float integral; //integral term
float derivative; //derivative term


while(true)
 {

	error = power - velocity; //difference between current vs target velocity

	if(error<integralActiveZone && error !=0) //active integral zone
	{
			errorT += error; //adds error
	}else
	{
		errorT = 0;
	}

	if(errorT>50/ki) //caps error at 50
  {
		errorT = 50/ki;
  }
	if(error == 0) //if error zero then derivative zero
	{
		derivative = 0;
	}

	proportion = error * kp; //setting proportion term
	integral = errorT * ki; //setting integral term
	derivative = (error - lastError)*kd;//setting derivative term

	lastError = error; //last error becomes current error for next loop

	current = proportion + derivative + integral; //setting power

	motor[flyWheelL1] = motor[flyWheelL2] = current; //giving motors power

	wait1Msec(20); //proventing hogging of CPU power

 }
}

task getVelocity() {
	while(1 == 1)
	{
	int gearRatio = 35;
 	int timeDelay = 20;
 	int ticks = 90;

 	float leftEncoderLast;
 	float rightEncoderLast;
 	float rightEncoder;
 	float leftEncoder;
 	float leftVelocity;
 	float rightVelocity;
 	float avgVelocity;
 	float speedRPM;


 	leftEncoder = SensorValue[I2C_1];
 	rightEncoder = SensorValue[I2C_2];

 	leftVelocity = (leftEncoder - leftEncoderLast)/(timeDelay * 0.001);
 	rightVelocity = (rightEncoder - rightEncoderLast)/(timeDelay * 0.001);

 	avgVelocity = (leftVelocity + rightVelocity)/2;

	leftEncoderLast = leftEncoder;
	rightEncoderLast = rightEncoder;


	speedRPM = avgVelocity * gearRatio * 60 * ticks;


	wait1Msec(timeDelay);

	}
}
